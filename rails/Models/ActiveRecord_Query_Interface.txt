File Name       : ActiveRecord_Query_Interfacec.txt
Author          : Dipanshu Ranga (@dip-beryl)
Organization    : Beryl Systems Pvt. Ltd.

----------------------------------------------------------------------------------------------------------------------------
1. Active Record Query Interface:

    - In Active Record we have better ways to find data instead of SQL Queries.
    
    - Active Record will perform queries on the database for you and is compatible with MySQL, MariaDB, PostgreSQL and SQLite3.

    ------------------

2. Retrieving Objects from The Database :

    - This is done by finder methods.

        - annotate
        - find
        - create_with
        - distinct
        - eager_load
        - extending
        - extract_associated
        - from
        - group
        - having
        - includes
        - joins
        - left_outer_joins
        - limit
        - lock
        - none
        - offset
        - optimizer_hints
        - order
        - preload
        - readonly
        - references
        - reorder
        - reselect
        - reverse_order
        - select
        - where

    NOTE : Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation. 
            
            Methods that find a single entity, such as find and first, return a single instance of the model.

        
        ------------------------------ Retrieving a Single Object -----------------------------

    * .find

        - Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options.

        > Blog.find(2)
        >>
            Blog Load (0.6ms)  SELECT "blogs".* FROM "blogs" WHERE "blogs"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
            =>                                                         
            #<Blog:0x0000560696bed640                                   
            id: 2,                                                     
            name: "Blog_2",                                            
            author_id: 2,                                              
            created_at: Mon, 05 Sep 2022 12:14:39.092795000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:36.728128000 UTC +00:00> 


        > Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)

        > Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)

        NOTE : The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.

        ---------------------------------

    * .take

        - The take method retrieves a record without any implicit ordering.
        
        
        > Blog.take
        >> 
            Blog Load (0.9ms)  SELECT "blogs".* FROM "blogs" LIMIT $1  [["LIMIT", 1]]
            =>                    
            #<Blog:0x0000560696dd52f0
            id: 1,
            name: "Blog_1",
            author_id: 2,
            created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:33.764925000 UTC +00:00> 

            
        > Blog.take(3)
        >>
            3 results of top.

        -------------------------------------------------------------------------------------

        * .first / .last

            - returns the value which has smallest Primary Key or first pimary key.

        
        -----------------------------------------------------------------------------------------

    *- .find_by

        - The find_by method finds the first record matching some conditions.

        Example:

            > Customer.find_by first_name: 'Lifo'
            > Customer.find_by first_name: 'Jon'


                - It is similar to :

            > Customer.where(first_name: 'Lifo').take

        -----------------------------------------------------------------------------------------

        -------------  Retrieving Multiple Objects in Batches ----------------

    *- .all.each

        - Itetrating over records.

            > Blog.all.each do |blog|
                puts blog.name
            end
            >>
                Blog Load (1.1ms)  SELECT "blogs".* FROM "blogs"

                Blog_1                                                                               
                Blog_2                                                                               

        - But this approach becomes increasingly impractical as the table size increases, 
            since Customer.all.each instructs Active Record to fetch the entire table in a single pass            

        - build a model object per row, and then keep the entire array of model objects in memory. 
            Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.


        ---> Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing:

            - find_each
            - find_in_batches

        -------------------------------------------------
    
    *- .find_each

        - The find_each method retrieves records in batches and then yields each one to the block.

        - Retrieves records in batches of 1000 and yields them to the block one by one:

        Example:

            Customer.find_each do |customer|
                puts customer.name
            
            end


            - Options in "find_each"
                - :batche_size  -> specify the batch size
                - :start        -> mention start position (:id)
                - :finish       -> mention end position (:id)
                - :error_on_ignore -> Overrides the application config to specify if an error should be raised when an order is present in the relation.


        --------------------------------------------------------

    * - .find_in_batches

        - The find_in_batches method is similar to find_each, since both retrieve batches of records.

        - The difference is that find_in_batches yields batches to the block as an array of models, instead of individually.

        - Array Block size is here too 1000

        Example :

            Customer.find_in_batches do |customer|
                customer do |c|
                    puts c.name
                end
            end

        - Options : :batchsize, ,:start, ,:finish, :error_on_ignore

    -----------------------------------------------------------------------

3. Conditions : (.where)

    - The "where method" allows you to specify conditions to limit the records returned, representing the WHERE-part of the SQL statement. 
    
    - Conditions can either be specified as:
            
            - String
            - Array
            - Hash.


        3.1 Pure String Conditions :

            - If you'd like to add conditions to your find, you could just specify them in there,
            
            Example:
                
                > Book.where("title = 'Introduction to Algorithms'")

                    - finds all the books where the title field value is 'Introduction to Algorithms'.


            NOTE : String Conditions are not safe with SQL Injection

            -----------
        3.2 Array Conditions :

            - Now what if that title could vary:

            Example:

                1. > Book.where("title =?", params[:title])

            NOTE : Book.where("title = #{params[:title]}")  <----- this way is NOT reccomended over the Example-1

                
                2. > Book.where("title = ? AND out_of_print = ?", params[:title], false)

                    - (?) will get replaced by the array values one by one.

                    - In example-2 the 1st(?) will take values from array and 2nd(?) will get value "false" for approach


                3. Placeholder Example:
                
                        > Book.where("created_at >= :start_date AND created_at <= :end_date", 
                                                                        {start_date: params[:start_date], end_date: params[:end_date]})

                4. LIKE Example :

                    - Although condition arguments are automatically escaped to prevent SQL injection.
                    
                    - But, SQL LIKE wildcards (i.e., % and _) are not escaped

                    - So we will use "sanitize_sql_like" in these type of cases

                    Example:

                        > Book.where("title LIKE ?", Book.sanitize_sql_like(params[:title]) + "%")

            -------------------------------------------
        3.3 Hash Conditions :

            - Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. 

            - Only :
                    Equality, Range, and Subset 
                                                checking are possible with Hash conditions.

            Example:

                3.3.1 Equality Condition :

                > Book.where(out_of_print: true)

                    Equivalent to - "SELECT * FROM books WHERE (books.out_of_print = 1)"

                    ---------------------------------------------------------------------
                
                3.3.2 Range Condition :

                    > Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

                    -----------------------------------------------------------------------
                
                3.3.3 Subset Condition :

                    > Customer.where(orders_count: [1,3,5])

                        Equivalent to - "SELECT * FROM customers WHERE (orders_count IN (1,3,5))"

            --------------------------------------------------------------------------------
        3.4 NOT Condition :

            > Customer.where.not(name: "Rahul")

            --------------------------------------------------
        3.5 OR Condition :

            > Cutomer.where(name: "Rahul").or(Cutomer.where(name: "Suhani"))
            
            --------------------------------------------------------------------------
        3.6 AND Condition :

            > Customer.where(age > 18).and(Cutomer.where(name: "Rahul"))    # .and method

            OR

            > Customer.where(age > 18).where(name: "Rahul"))                # chaining where method
        
        
        -----------------------------------------------------------------------------------------------------
