File Name       : ActiveRecord_Query_Interfacec.txt
Author          : Dipanshu Ranga (@dip-beryl)
Organization    : Beryl Systems Pvt. Ltd.

----------------------------------------------------------------------------------------------------------------------------
1. Active Record Query Interface:

    - In Active Record we have better ways to find data instead of SQL Queries.
    
    - Active Record will perform queries on the database for you and is compatible with MySQL, MariaDB, PostgreSQL and SQLite3.

    ------------------

2. Retrieving Objects from The Database :

    - This is done by finder methods.

        - annotate
        - find
        - create_with
        - distinct
        - eager_load
        - extending
        - extract_associated
        - from
        - group
        - having
        - includes
        - joins
        - left_outer_joins
        - limit
        - lock
        - none
        - offset
        - optimizer_hints
        - order
        - preload
        - readonly
        - references
        - reorder
        - reselect
        - reverse_order
        - select
        - where

    NOTE : Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation. 
            
            Methods that find a single entity, such as find and first, return a single instance of the model.

        
        ------------------------------ Retrieving a Single Object -----------------------------

    * .find

        - Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options.

        > Blog.find(2)
        >>
            Blog Load (0.6ms)  SELECT "blogs".* FROM "blogs" WHERE "blogs"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
            =>                                                         
            #<Blog:0x0000560696bed640                                   
            id: 2,                                                     
            name: "Blog_2",                                            
            author_id: 2,                                              
            created_at: Mon, 05 Sep 2022 12:14:39.092795000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:36.728128000 UTC +00:00> 


        > Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)

        > Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)

        NOTE : The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.

        ---------------------------------

    * .take

        - The take method retrieves a record without any implicit ordering.
        
        
        > Blog.take
        >> 
            Blog Load (0.9ms)  SELECT "blogs".* FROM "blogs" LIMIT $1  [["LIMIT", 1]]
            =>                    
            #<Blog:0x0000560696dd52f0
            id: 1,
            name: "Blog_1",
            author_id: 2,
            created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:33.764925000 UTC +00:00> 

            
        > Blog.take(3)
        >>
            3 results of top.

        -------------------------------------------------------------------------------------

        * .first / .last

            - returns the value which has smallest Primary Key or first pimary key.

        
        -----------------------------------------------------------------------------------------

    *- .find_by

        - The find_by method finds the first record matching some conditions.

        Example:

            > Customer.find_by first_name: 'Lifo'
            > Customer.find_by first_name: 'Jon'


                - It is similar to :

            > Customer.where(first_name: 'Lifo').take

        -----------------------------------------------------------------------------------------

        -------------  Retrieving Multiple Objects in Batches ----------------

    *- .all.each

        - Itetrating over records.

            > Blog.all.each do |blog|
                puts blog.name
            end
            >>
                Blog Load (1.1ms)  SELECT "blogs".* FROM "blogs"

                Blog_1                                                                               
                Blog_2                                                                               

        - But this approach becomes increasingly impractical as the table size increases, 
            since Customer.all.each instructs Active Record to fetch the entire table in a single pass            

        - build a model object per row, and then keep the entire array of model objects in memory. 
            Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.


        ---> Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing:

            - find_each
            - find_in_batches

        -------------------------------------------------
    
    *- .find_each

        - The find_each method retrieves records in batches and then yields each one to the block.

        - Retrieves records in batches of 1000 and yields them to the block one by one:

        Example:

            Customer.find_each do |customer|
                puts customer.name
            
            end


            - Options in "find_each"
                - :batche_size  -> specify the batch size
                - :start        -> mention start position (:id)
                - :finish       -> mention end position (:id)
                - :error_on_ignore -> Overrides the application config to specify if an error should be raised when an order is present in the relation.


        --------------------------------------------------------

    * - .find_in_batches

        - The find_in_batches method is similar to find_each, since both retrieve batches of records.

        - The difference is that find_in_batches yields batches to the block as an array of models, instead of individually.

        - Array Block size is here too 1000

        Example :

            Customer.find_in_batches do |customer|
                customer.each do |c|
                    puts c.name
                end
            end

        - Options : :batchsize, ,:start, ,:finish, :error_on_ignore

    -----------------------------------------------------------------------

3. Conditions : (.where)

    - The "where method" allows you to specify conditions to limit the records returned, representing the WHERE-part of the SQL statement. 
    
    - Conditions can either be specified as:
            
            - String
            - Array
            - Hash.


    3.1 Pure String Conditions :

        - If you'd like to add conditions to your find, you could just specify them in there,
        
        Example:
            
            > Book.where("title = 'Introduction to Algorithms'")

                - finds all the books where the title field value is 'Introduction to Algorithms'.


        NOTE : String Conditions are not safe with SQL Injection

        -----------
    3.2 Array Conditions :

        - Now what if that title could vary:

        Example:

            1. > Book.where("title =?", params[:title])

        NOTE : Book.where("title = #{params[:title]}")  <----- this way is NOT reccomended over the Example-1

            
            2. > Book.where("title = ? AND out_of_print = ?", params[:title], false)

                - (?) will get replaced by the array values one by one.

                - In example-2 the 1st(?) will take values from array and 2nd(?) will get value "false" for approach


            3. Placeholder Example:
            
                    > Book.where("created_at >= :start_date AND created_at <= :end_date", 
                                                                    {start_date: params[:start_date], end_date: params[:end_date]})

            4. LIKE Example :

                - Although condition arguments are automatically escaped to prevent SQL injection.
                
                - But, SQL LIKE wildcards (i.e., % and _) are not escaped

                - So we will use "sanitize_sql_like" in these type of cases

                Example:

                    > Book.where("title LIKE ?", Book.sanitize_sql_like(params[:title]) + "%")

        -------------------------------------------
    3.3 Hash Conditions :

        - Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. 

        - Only :
                Equality, Range, and Subset 
                                            checking are possible with Hash conditions.

        Example:

            3.3.1 Equality Condition :

            > Book.where(out_of_print: true)

                Equivalent to - "SELECT * FROM books WHERE (books.out_of_print = 1)"

                ---------------------------------------------------------------------
            
            3.3.2 Range Condition :

                > Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

                -----------------------------------------------------------------------
            
            3.3.3 Subset Condition :

                > Customer.where(orders_count: [1,3,5])

                    Equivalent to - "SELECT * FROM customers WHERE (orders_count IN (1,3,5))"

        --------------------------------------------------------------------------------
    3.4 NOT Condition :

        > Customer.where.not(name: "Rahul")

        --------------------------------------------------
    3.5 OR Condition :

        > Cutomer.where(name: "Rahul").or(Cutomer.where(name: "Suhani"))
        
        --------------------------------------------------------------------------
    3.6 AND Condition :

        > Customer.where(age > 18).and(Cutomer.where(name: "Rahul"))    # .and method

        OR

        > Customer.where(age > 18).where(name: "Rahul"))                # chaining where method
    
    
    -----------------------------------------------------------------------------------------------------

4. ORDER :

    - To retrieve records from the database in a specific order, you can use the order method.

    Example :

        > Book.order(:created_at)
            OR
        > Book.order("created_at")


        > Book.order(created_at: :asc)
            OR
        > Book.order("created_at DESC")


    --------------------------------------------------------------------------------------------------

5. SELECT :

    - By default, "Model.find" selects all the fields from the result set using [ select * ].

    - To select only a subset of fields from the result set, you can specify the subset via the ".select" method.

    Example :

        > Book.select(:isbn, :out_of_print)
                OR
        > Book.select("isbn, out_of_print")

                Equivalent to - " SELECT isbn, out_of_print FROM books "


        > Blog.select(:name)
        >> 
            Blog Load (1.1ms)  SELECT "blogs"."name" FROM "blogs"

            =>                                                                             
            [#<Blog:0x00007f22fc9a20d8 id: nil, name: "Blog_1">,                            
            #<Blog:0x00007f22fc9a1f48 id: nil, name: "Blog_2">]                            


    - DISTINCT SELECT :

        > Customer.select(:last_name).distinct

    --------------------------------------------------------------------------------------------------

6. LIMIT and OFFSET :

    - To apply LIMIT to the SQL fired by the "Model.find", you can specify the LIMIT using limit and offset methods on the relation.


    > Blog.limit(5)     # will select top five records


    > Blog.limit(5).offset(2)   # will first skip 2 records then select 5 records

    --------------------------------------------------------------------------------------------------

7. GROUP :

    - To apply a GROUP BY clause to the SQL fired by the finder, you can use the group method.

    Example:

        > Student.select("age").group("age")

            Equivalent to : " SELECT age FROM students GROUP BY age; "

        
        > Student.group(:city).count    # gets the count of all the distinct cities

            Equivalent to : " SELECT COUNT(city) FROM students GROUP BY city; "

    ---------------------------------------------------------------------------------------------------

8. HAVING :

    - You can add the HAVING clause to the SQL fired by the "Model.find" by adding the "having" method to the find.


    > Student.select("city, COUNT(city) AS city_count")
                .group(:city)
                .having("COUNT(city) > ?", 5)

        Equivalent to : SELECT 
                                city, 
                                COUNT(city) AS city_count 
                        FROM 
                            students 
                        GROUP BY 
                            city 
                        HAVING 
                            COUNT(city) > 5; "


    --> Passing the above Object to a varibale :

    > cities = Student.select("city, COUNT(city) AS city_count")
                        .group(:city)
                        .having("COUNT(city) > ?", 5)

    > cities[0].city_count
    >>      # will return first entry from "city_count" column of above query.

    
    -----------------------------------------------------------------------------------------------------------------------------------

9. Overriding :

    9.1 unscope :

        - You can specify certain conditions to be removed using the "unscope" method.
        
        Example:

            > Book.where('id > 100').limit(20).order('id desc').unscope(:order)

                Equivalent to : SELECT * 
                                FROM books 
                                WHERE id > 100 
                                LIMIT 20

                    - If we haven't used [ .unscope ]

                                : SELECT * 
                                FROM books 
                                WHERE id > 100 
                                ORDER BY id DESC
                                LIMIT 20

        
        - Can remove specific .where conditions too :

            > Student.where(first_name: "Rahul",  last_name: "Gandh").unscope(where: :last_name)

                    Equivalent to - SELECT * FROM students WHERE first_name = "Rahul";

        -------------------------------------------------------------------------------------------------

    9.2 only :

        - Only is opposite of unscope

        - In .only only the methods you mention will get performed.


            > Book.where('id > 10').limit(20).order('id desc').only(:order, :where)

                    Equivalent to : SELECT * FROM books
                                    WHERE id > 10
                                    ORDER BY id DESC

                                    # .limit method is skipped as it wasn't mentioned in .only

        -------------------------------------------------------------------------------------------------------

    9.3 reselect :

        - The reselect method overrides an existing select statement. For example:

            > Student.select(:name, :roll_no).reselect(:age)

                Equivalent to :  SELECT age FROM students;

        --------------------------------------------------------------------------------------------------

    9.4 reorder :

        - If your association have already specified any ordering way. Then you can use .reorder to override it.

        Example:

        Model:
        -----------------------------------------------------
            def Author < ApplicationRecord
                has_many :blogs, -> { order(isbn: :desc) }
            end
        -----------------------------------------------------

        --> When we run

            > Author.find(10).blogs
            >>  # result will be order by isbn: :desc (default)

                Equivalent to : SELECT * FROM blogs
                                WHERE author_id = 10
                                ORDER BY isbn DESC

        --> Overriding Order:

            > Author.find(10).blogs.reorder(:name)
            >>  # result will be ordered by :name

                Equivalent to : SELECT * FROM blogs
                                WHERE author_id = 10
                                ORDER BY name

        -------------------------------------------------------------------------------------------------------

    9.5 reverse_order :

        - The reverse_order method reverses the ordering clause if specified.

            > Blog.order(:id).reverse_order


        - If no ordering clause is specified in the query, the reverse_order orders by the primary key in reverse order.

            > Book.where("author_id > 10").reverse_order


        ---------------------------------------------------------------------------

    9.6 rewhere

        - The rewhere method overrides an existing, named where condition.

        Example :

            > Student.where(age > 10).rewhere(age < 10)

                Equivalent to : SELECT * FROM students WHERE age < 10;

    -------------------------------------------------------------------------------------------------------------------

10. None.

    > Blog.none
    >> []

    -- Returns an empty relation and fires no Queries.

    --------------------------------------------------------------------------------------------

11. Readonly Objects :

    - Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects. 
    
    - Any attempt to alter a readonly record will not succeed, raising an "ActiveRecord::ReadOnlyRecord" exception.

        > blog = Blog.readonly.first

        > blog
        >>
            #<Blog:0x000055b9a7ec47d8                                                                  
            id: 1,                                                                                    
            name: "Blog_1",                                                                           
            author_id: 2,                                                                             
            created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,                               
            updated_at: Mon, 05 Sep 2022 12:17:33.764925000 UTC +00:00>                               
        
        > blog.id = 10
        >> 10

        > blog.save
        >>
            TRANSACTION (0.5ms)  BEGIN
            Author Load (0.6ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
            TRANSACTION (0.4ms)  ROLLBACK                             
            
            ........rb:1123:in `_raise_readonly_record_error': Blog is marked as readonly (ActiveRecord::ReadOnlyRecord)

                # transaction Rolled back because you cannot modify data through this object as this is a readonly object.

        Useful :
                .readonly?
                .readonly!

    ---------------------------------------------------------------------------------------------------------------------------------

12. Locking Records :

    -  Locking is helpful when many people are working on database.

    - Because of locking we can have atomic updates without conflicts.

    - ActiveRecord Support two locking Mechanisms :

        1. Optimistic Locking
        2. Passimistic Locking

    
    12.1 Optimistic Locking :

        - Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. 
        
        - It does this by checking whether another process has made changes to a record since it was opened.

        - An "ActiveRecord::StaleObjectError" exception is thrown if that has occurred and the update is ignored.



        - In order to use optimistic locking, the table needs to have a column called [ "lock_version" ]  of type integer. 
        - Each time the record is updated, Active Record increments the lock_version column

        - If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database, 
                    then the update request will fail with an "ActiveRecord::StaleObjectError".

            
            $ rails g migration AddLockVersionToBlogs lock_version:integer

            > b1 = Blog.first
            > b2 = Blog.first

            > b1.name = "Laptop under 10000"
            > b1. save

            > b1
            >>
                #<Blog:0x000055d4f37051c0
                id: 1,
                name: "Laptops under 10000",
                author_id: 2,
                created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,
                updated_at: Wed, 07 Sep 2022 09:39:37.030568000 UTC +00:00,
                lock_version: 1>

            > b2.name = "New Blog"
            > b2.save
            >>
                TRANSACTION (0.5ms)  BEGIN
                Author Load (0.8ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
                Blog Update (0.9ms)  UPDATE "blogs" SET "name" = $1, "updated_at" = $2, "lock_version" = $3 WHERE "blogs"."id" = $4 AND "blogs"."lock_version" IS NULL  [["name", "New Blog"], ["updated_at", "2022-09-07 09:40:11.766934"], ["lock_version", 1], ["id", 1]]
                TRANSACTION (0.4ms)  ROLLBACK
                
                .......rb:108:in `_update_row': Attempted to update a stale object: Blog. (ActiveRecord::StaleObjectError)

                        *- Transaction / Update isn't completed because the lock version "b2" is older then that in DB.

        
        - This behavior can be turned off by setting ActiveRecord::Base.lock_optimistically = false.

        - To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column:

                ----------------------------------------
                    class Blog < ApplicationRecord
                        self.locking_column = :lock_blog_column
                    end
                ----------------------------------------

    12.2 Pessimistic Locking :

        - Pessimistic locking uses a locking mechanism provided by the underlying database. 
        
        - Using lock when building a relation obtains an exclusive lock on the selected rows.    

        - This is aDB concept but can be used witjh .with_lock

    -------------------------------------------------------------------------------------------------------------------------------

13. JOINS :

    NOTE : SQL Inner Join is same as JOIN

    
    13.1 String Format :

        Author.joins("JOIN blogs ON ("blogs.author_id = author.id")

            Equivalent to : SELECT * FROM authors JOIN blogs ON (blogs.author_id = author.id);

        -----------------------------------------------
    13.2 Array / Hash Format :


        13.2.1. Single Association Joining :

        - Active Record lets you use the names of the associations defined on the model as a shortcut for specifying JOIN clauses.
             for those associations when using the joins method.

        Example:
            
            $ rails g migration CreateComments title:string body:text student:references blog:references

            Model :
            ------------------------------------------------------
                class Comment < ApplicationRecord
                    belongs_to :blog 
                end

                class Blog < ApplicationRecord
                    belongs_to :author
                    has_many :comments
                end
            ------------------------------------------------------

                *- Now, When we join tables who are associated to each other.
                        We do not need to mention the column name on which the joinig is based.

                
        ------- > Blog.joins(:comments)
                >>
                    Blog Load (51.7ms)  SELECT "blogs".* FROM "blogs" 
                    INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id"

                
                - Or, in English: "return a Blog object for all blogs with comments". 
                - Note that you will see duplicate blogs if a blog has more than one comment. 
                
                --> If you want unique blogs, you can use Blog.joins(:comments).distinct.
            
            -----------------------------------------
        13.2.2. Multiple Association Joining :

                > Blog.joins(:author, :comments)
                >>

                    Blog Load (1.5ms)  
                        SELECT "blogs".* FROM "blogs" 
                            INNER JOIN "authors" ON "authors"."id" = "blogs"."author_id" 
                            INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 


                    *- Or, in English: "return all blogs with their author that have at least one comment". 
                            Note again that blogs with multiple comments will show up multiple times.

            ----------------------------------------
        13.2.3. Nested Association Joining :

            Model:
            -------------------------------------------------------
                class Comment < ApplicationRecord
                    belongs_to :blog 
                    belongs_to :student
                end

                class Student < ApplicationRecord
                    has_many :comments
                end
            -------------------------------------------------------

                > Blog.join(comments: :student)
                >>
                      Blog Load (1.1ms)  
                        SELECT "blogs".* FROM "blogs" 
                            INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 
                            INNER JOIN "students" ON "students"."id" = "comments"."student_id"

                        *- Or, in English: "return all blogs that have a comment by a student."

            --------------------------------------------------------------------

        13.2.4. Nested Association Joining (Multiple Level) :

        
        ------------------------------------------------------------------

    13.3 Specifying Conditions(.where) on JOINS :

        - Using String :

            > Blog.joins(:comments).where('comments.created_at' => "2022-05-01")

                OR

        - Using Hash :

            > Blog.joins(:comments).where(comments: {created_at: "2022-05-01"})


            >> Blog Load (1.2ms)  
                SELECT "blogs".* FROM "blogs" 
                    INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 
                WHERE "comments"."created_at" = $1  [["created_at", "2022-05-01 00:00:00"]]

        -----------------------------------------------------------------------------------------------

    13.4 LEFT OUTER JOIN :

        - If you want to select a set of records whether or not they have associated records you can use the left_outer_joins method.

            > Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')

            >>  SELECT DISTINCT customers.*, 
                                COUNT(reviews.*) AS reviews_count 
                FROM customers
                LEFT OUTER JOIN reviews 
                        ON reviews.customer_id = customers.id 
                GROUP BY customers.id


    -------------------------------------------------------------------------------------------------------------------------------

14 Eager Loading Associations :

    - Eager loading is the mechanism for loading the associated records of the objects returned by Model.find using as few queries as possible.

    **** N + 1 queries problem ****

    ----------------------------------
        > books = Book.limit(10)

        > books.each do |book|
            puts book.author.last_name
          end
    ----------------------------------

        - This code looks fine at the first sight. But the problem lies within the total number of queries executed. 
        
        - The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = 11 queries in total.


    Solution :

    Active Record lets you specify in advance all the associations that are going to be loaded.

    The methods are:

        * includes
        * preload
        * eager_load

    14.1. includes

        - With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.

        ----------------------------------------------
            > books = Book.includes(:author).limit(10)          # loading

            > books.each do |book|
                puts book.author.last_name
              end
        ----------------------------------------------

            - The above code will execute just 2 queries, as opposed to the 11 queries from the original case:

                Equivalent to : SELECT `books`.* FROM `books` LIMIT 10

                                SELECT `authors`.* FROM `authors`
                                WHERE `authors`.`book_id` IN (1,2,3,4,5,6,7,8,9,10)

            
            -------------------------------------------------------
        14.1.1 Eager Loading With Multiple Associatons :

            - Active Record lets you eager load any number of associations with a single Model.find call by using:
            
                - array 
                - hash
                - nested hash of array/hash with the includes method

            1. Array of Multiple Associations :

                > Blog.includes(:comments, :author)
                >>
                    Blog Load (170.0ms)  SELECT "blogs".* FROM "blogs"
                    Comment Load (28.0ms)  SELECT "comments".* FROM "comments" WHERE "comments"."blog_id" IN ($1, $2)  [["blog_id", 2], ["blog_id", 1]]                           
                    Author Load (46.3ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1  [["id", 2]] 

                        *- This loads all the blogs and the associated comments and authors for each.

                --------------------------------------------------------------------------------------
            2. Nested Associations Hash

                > Customer.includes(orders: {books: [:supplier, :author]}).find(1)

                        *- This will find the customer with id 1 and eager load all of the associated orders for it, 
                                the books for all of the orders, and the author and supplier for each of the books.

            ------------------------------------------------------------
        14.1.2 Conditions on Eager Load :

            - Even though Active Record lets you specify conditions on the eager loaded associations just like joins, the recommended way is to use joins instead

            - However if you must do this, you may use "where" as you would normally.

        -------------------------------------------------------------------------------------------------

    14.2 preload :

        - Rails has 2 ways of avoiding the n+1 problem. 
            
            - eager_load : One involves creating a "big (LEFT outer)join based query" to pull in your associations, 
            - preload    : The other involves "making a separate query per association". (2 query solution)

        - When you do "includes" rails automatically decides which strategy to use for you. [Default is 2 Query i.e., Preload in itself ]

        - With preload, Active Record loads each specified association using one query per association.

        Example:

            ----------------------------------------------
            > books = Book.preload(:author).limit(10)          # loading

            > books.each do |book|
                puts book.author.last_name
              end
            ----------------------------------------------
                *- Output will be same as above includes example as both is using same method.

        ---------------------------------------------------------------------------------------

    14.3 eager_load :

        - With eager_load, Active Record loads all specified associations using a LEFT OUTER JOIN.

        Example: "same but with eager_load"

            ------------------------------------------------------------
                books = Book.eager_load(:author).limit(10)

                books.each do |book|
                    puts book.author.last_name
                end
            ------------------------------------------------------------

                    SELECT DISTINCT `books`.`id` FROM `books` 
                    LEFT OUTER JOIN `authors` 
                        ON `authors`.`book_id` = `books`.`id` 
                    LIMIT 10

                    SELECT `books`.`id` AS t0_r0, `books`.`last_name` AS t0_r1, ...
                    FROM `books` 
                        LEFT OUTER JOIN `authors` 
                            ON `authors`.`book_id` = `books`.`id`
                    WHERE `books`.`id` IN (1,2,3,4,5,6,7,8,9,10)

    NOTE : It is not possible to specify conditions for "preloaded" associations.
                BUT,
           You can specify conditions for "eager loaded" associations.

           When you specify conditions in "include loaded" associations it automatically uses "eager_load"

                - Here conditions means : .where()
                
                - Loaded Associations means the table you pass in the arguments of preload() or eager_load()

    
    -----------------------------------------------------------------------------------------------------------------------

15 .Scopes :


    ----------------------------------------------------------------------------------------------------------------------

16. Dynamic Finders :

    - For every field / column (also known as an attribute) you define in your table 
    
            - Active Record provides a finder method.

    Example:

        Model : Blog
        Field : name

        There will be a method automatically defined for Blog model ie., "find_by_name"

            > Blog.find_by_name("Blog_2")
            >>
                Blog Load (76.9ms)  SELECT "blogs".* FROM "blogs" WHERE "blogs"."name" = $1 LIMIT $2  [["name", "Blog_2"], ["LIMIT", 1]]

                => 
                #<Blog:0x00007f41d40945f8
                id: 2,
                name: "Blog_2",
                author_id: 2,
                created_at: Mon, 05 Sep 2022 12:14:39.092795000 UTC +00:00,
                updated_at: Mon, 05 Sep 2022 12:17:36.728128000 UTC +00:00,
                lock_version: 0> 


    - You can specify an exclamation point (!) on the end to get them to raise an "ActiveRecord::RecordNotFound" error, if they do not return any records.

            > Blog.find_by_name("Blog_16")

    
    - You can go even one step further by chaining these dynamic finders with the help of "_and_"

            .find_by_name  +  .find_by_created_at

            > Blog.find_by_name_and_created_at("Bolg_15", 2020-12-20)

    ---------------------------------------------------------------------------------------------------------------------------------

17. Enums :

    - An enum lets you define an Array of values for an attribute and refer to them by name. 

    - The actual value stored in the database is an "integer that has been mapped" to one of the values.

        Understand This :
                            1. Enum acts as a inclusion validator in itself
                            2. Enum's integer starts from 0 index.
                            3. While inserting values in the column that we have mapped with an Enum.
                                    - we can either pass the indexes, string values from enum, or symbols from enum.
                            4. But the d-type of the column / field in the migration must be Integer.

        Example : ("status" is the enum column here)

        $ rails g migration CreateOrders date:date status:integer total:float customer:references

        $ rails db:migrate

        Model :
        ----------------------------------------------------
            class Order < ApplicationRecord
                belongs_to :customer

                enum :status, [:shipped, :processing, :cancelled, :delivered]
            end

            class Customer < ApplicationRecord
                has_many :orders
            end
        ----------------------------------------------------

            > c1 = Customer.create(name: "Ajay", contact: "8792371112")
            > c2 = Customer.create(name: "Vijay", contact: "9898291828")
            > c3 = Customer.create(name: "Sanjay", contact: "8889128372")

            > c1.orders.create(date: Time.now, status: "shipped", total: 105.5)     # passing value for "status" in string from Enum
            
            > c2.orders.create(date: Time.now, status: 0, total: 105.5)             # passing value for "status" as an integer that is mapped to ENum
            >>
                TRANSACTION (0.5ms)  
                BEGIN
                Order Create (1.2ms)  
                    INSERT INTO "orders" ("date", "status", "total", "customer_id", "created_at", "updated_at") 
                        VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"  [["date", "2022-09-08"], ["status", 0], ["total", 105.5], ["customer_id", 2], ["created_at", "2022-09-08 06:45:40.142458"], ["updated_at", "2022-09-08 06:45:40.142458"]]
                TRANSACTION (29.3ms)  
                COMMIT
                
                => 
                #<Order:0x000055ae8561c388
                id: 2,
                date: Thu, 08 Sep 2022,
                status: "shipped",
                total: 105.5,
                customer_id: 2,
                created_at: Thu, 08 Sep 2022 06:45:40.142458000 UTC +00:00,
                updated_at: Thu, 08 Sep 2022 06:45:40.142458000 UTC +00:00> 

            
            > c2.orders.create(date: Time.now, status: :delivered, total: 35.5)    # passing value for "status" in symbol from Enum
            
            > c3.orders.create(date: Time.now, status: 1, total: 335.5)


        Example of Enum fetching:

            > Order.shipped
            >>
                Order Load (0.9ms)  SELECT "orders".* FROM "orders" WHERE "orders"."status" = $1  [["status", 0]]
                
                =>                                                          
                [#<Order:0x000055ae84f9ed80                                  
                id: 1,                                                     
                date: Thu, 08 Sep 2022,                                    
                status: "shipped",                                         
                total: 105.5,                                              
                customer_id: 1,                                            
                created_at: Thu, 08 Sep 2022 06:45:19.549168000 UTC +00:00,
                updated_at: Thu, 08 Sep 2022 06:45:19.549168000 UTC +00:00>,
                
                #<Order:0x000055ae84f9ec68                                  
                id: 2,                                                     
                date: Thu, 08 Sep 2022,                                    
                status: "shipped",                                         
                total: 105.5,                                              
                customer_id: 2,
                created_at: Thu, 08 Sep 2022 06:45:40.142458000 UTC +00:00,
                updated_at: Thu, 08 Sep 2022 06:45:40.142458000 UTC +00:00>] 


                    *- we can fetch all the records from enum values also 
                     do not need to write whole query like :
                        > Order.where(status: :shipped)

            NOTE: 
                    - We can pass values in an form int, string or symbol.
                    - But the DB will save values only in integer form.
                    - But, Whenever we fetch record with the help of ActiveRecord it also fetches the value of integer values from ENum in the model.
                    - Thats why we can see [ status: "shipped" ] instead of [ status: 0 ].


            - There are dynamic options too. Like

                > Order.shipped!        (!)

                > order_obj.shipped?        (?)

                > Order.not_shipped         (not_)
                    
                        - problem with above query is that it will also show "delivered" products

                > Order.not_shipped.not_delivered
                        
                        - this query will show products that are not yet shipped also that are not yet delivered.

    
    ------------------------------------------------------------------------------------------------------------------------

18. Method Chaining :

    - The Active Record pattern implements Method Chaining, which allow us to use multiple Active Record methods together in a simple and straightforward way.
    
    - You can chain methods in a statement when the previous method called 
    
        returns an "ActiveRecord::Relation", like:
            - all
            - where, and 
            - joins.

    - If there are Methods that return a single object (see Retrieving a Single Object Section) have to be at the end of the statement.

    Syntax / Example :

        > Customer
                .select('customers.id, customers.last_name, reviews.body')
                .joins(:reviews)
                .where('reviews.created_at > ?', 2020-12-31)


        > Book
            .select('books.id, books.title, authors.first_name')
            .joins(:author)
            .find_by(title: 'Abstraction and Specification in Program Development')


    ----------------------------------------------------------------------------------------------------------------------------------------

19. Find or Build a New Object :  (.find_or_create_by)

    - It's common that you need to find a record or create it if it doesn't exist

    - we can do this by :

    19.1   [ - .find_or_create_by ]

    Example :

            > Blog.find_or_create_by(name: "Windows 11 : New Age", author_id: 2)
            >>
                Blog Load (18.3ms)  
                    SELECT "blogs".* FROM "blogs" 
                    WHERE "blogs"."name" = $1 AND "blogs"."author_id" = $2 LIMIT $3  [["name", "Windows 11 : New Age"], ["author_id", 2], ["LIMIT", 1]]
                
                TRANSACTION (0.5ms)  BEGIN
                
                Author Load (0.6ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
                Blog Create (21.9ms)  INSERT INTO "blogs" ("name", "author_id", "created_at", "updated_at", "lock_version") 
                                            VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["name", "Windows 11 : New Age"], ["author_id", 2], ["created_at", "2022-09-08 07:43:36.786869"], ["updated_at", "2022-09-08 07:43:36.786869"], ["lock_version", 0]]
                
                TRANSACTION (23.8ms)  COMMIT                                              
                
                =>                                                                         
                #<Blog:0x000055b19b8c9d60                                 
                id: 4,                                       
                name: "Windows 11 : New Age",                
                author_id: 2,                                
                created_at: Thu, 08 Sep 2022 07:43:36.786869000 UTC +00:00,
                updated_at: Thu, 08 Sep 2022 07:43:36.786869000 UTC +00:00,
                lock_version: 0> 

                    *- Record did not exist. So ".find_or_create_by" method created it.

            > Blog.find_or_create_by(name: "Windows 11 : New Age", author_id: 2)
            >>
                Blog Load (1.0ms)  
                    SELECT "blogs".* FROM "blogs" 
                    WHERE "blogs"."name" = $1 AND "blogs"."author_id" = $2 LIMIT $3  
                        [["name", "Windows 11 : New Age"], ["author_id", 2], ["LIMIT", 1]]

                => 
                #<Blog:0x00007f1ac49d4168
                id: 4,
                name: "Windows 11 : New Age",
                author_id: 2,
                created_at: Thu, 08 Sep 2022 07:43:36.786869000 UTC +00:00,
                updated_at: Thu, 08 Sep 2022 07:43:36.786869000 UTC +00:00,
                lock_version: 0> 

                    *- Record was present. So i returned the record.

        -------------------------------------------
    
    19.2    .find_or_create_by!

            - You can also use find_or_create_by! to "raise an exception" if the new record is invalid.

                - New record is invalid
                - Validation Error

        -------------------------------------
    
    19.3    .find_or_initialize_by

            - This is also completely similar to ".find_or_create_by"

                -- only difference is that it initializes a ".new" object instead of ".create".

                -- So, we need to pass this methods return value to a variable.

                -- And, then call (.save) on that variable object to save the new record / data

                    -- But, If it finds the mentioned record it will pass the record to the variable.
                        And then you don't need to save it also you cannot save it unless you change its attributes' value.

        
        NOTE : 
                .persisted?

                    --> Returns "true" - if the record is persisted, 
                                    
                                        - persisted => itâ€™s not a new record and it was not destroyed

    ------------------------------------------------------------------------------------------------------------------------------

