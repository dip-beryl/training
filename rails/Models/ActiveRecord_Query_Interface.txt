File Name       : ActiveRecord_Query_Interfacec.txt
Author          : Dipanshu Ranga (@dip-beryl)
Organization    : Beryl Systems Pvt. Ltd.

----------------------------------------------------------------------------------------------------------------------------
1. Active Record Query Interface:

    - In Active Record we have better ways to find data instead of SQL Queries.
    
    - Active Record will perform queries on the database for you and is compatible with MySQL, MariaDB, PostgreSQL and SQLite3.

    ------------------

2. Retrieving Objects from The Database :

    - This is done by finder methods.

        - annotate
        - find
        - create_with
        - distinct
        - eager_load
        - extending
        - extract_associated
        - from
        - group
        - having
        - includes
        - joins
        - left_outer_joins
        - limit
        - lock
        - none
        - offset
        - optimizer_hints
        - order
        - preload
        - readonly
        - references
        - reorder
        - reselect
        - reverse_order
        - select
        - where

    NOTE : Finder methods that return a collection, such as where and group, return an instance of ActiveRecord::Relation. 
            
            Methods that find a single entity, such as find and first, return a single instance of the model.

        
        ------------------------------ Retrieving a Single Object -----------------------------

    * .find

        - Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options.

        > Blog.find(2)
        >>
            Blog Load (0.6ms)  SELECT "blogs".* FROM "blogs" WHERE "blogs"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
            =>                                                         
            #<Blog:0x0000560696bed640                                   
            id: 2,                                                     
            name: "Blog_2",                                            
            author_id: 2,                                              
            created_at: Mon, 05 Sep 2022 12:14:39.092795000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:36.728128000 UTC +00:00> 


        > Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)

        > Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)

        NOTE : The find method will raise an ActiveRecord::RecordNotFound exception unless a matching record is found for all of the supplied primary keys.

        ---------------------------------

    * .take

        - The take method retrieves a record without any implicit ordering.
        
        
        > Blog.take
        >> 
            Blog Load (0.9ms)  SELECT "blogs".* FROM "blogs" LIMIT $1  [["LIMIT", 1]]
            =>                    
            #<Blog:0x0000560696dd52f0
            id: 1,
            name: "Blog_1",
            author_id: 2,
            created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,
            updated_at: Mon, 05 Sep 2022 12:17:33.764925000 UTC +00:00> 

            
        > Blog.take(3)
        >>
            3 results of top.

        -------------------------------------------------------------------------------------

        * .first / .last

            - returns the value which has smallest Primary Key or first pimary key.

        
        -----------------------------------------------------------------------------------------

    *- .find_by

        - The find_by method finds the first record matching some conditions.

        Example:

            > Customer.find_by first_name: 'Lifo'
            > Customer.find_by first_name: 'Jon'


                - It is similar to :

            > Customer.where(first_name: 'Lifo').take

        -----------------------------------------------------------------------------------------

        -------------  Retrieving Multiple Objects in Batches ----------------

    *- .all.each

        - Itetrating over records.

            > Blog.all.each do |blog|
                puts blog.name
            end
            >>
                Blog Load (1.1ms)  SELECT "blogs".* FROM "blogs"

                Blog_1                                                                               
                Blog_2                                                                               

        - But this approach becomes increasingly impractical as the table size increases, 
            since Customer.all.each instructs Active Record to fetch the entire table in a single pass            

        - build a model object per row, and then keep the entire array of model objects in memory. 
            Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.


        ---> Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing:

            - find_each
            - find_in_batches

        -------------------------------------------------
    
    *- .find_each

        - The find_each method retrieves records in batches and then yields each one to the block.

        - Retrieves records in batches of 1000 and yields them to the block one by one:

        Example:

            Customer.find_each do |customer|
                puts customer.name
            
            end


            - Options in "find_each"
                - :batche_size  -> specify the batch size
                - :start        -> mention start position (:id)
                - :finish       -> mention end position (:id)
                - :error_on_ignore -> Overrides the application config to specify if an error should be raised when an order is present in the relation.


        --------------------------------------------------------

    * - .find_in_batches

        - The find_in_batches method is similar to find_each, since both retrieve batches of records.

        - The difference is that find_in_batches yields batches to the block as an array of models, instead of individually.

        - Array Block size is here too 1000

        Example :

            Customer.find_in_batches do |customer|
                customer.each do |c|
                    puts c.name
                end
            end

        - Options : :batchsize, ,:start, ,:finish, :error_on_ignore

    -----------------------------------------------------------------------

3. Conditions : (.where)

    - The "where method" allows you to specify conditions to limit the records returned, representing the WHERE-part of the SQL statement. 
    
    - Conditions can either be specified as:
            
            - String
            - Array
            - Hash.


    3.1 Pure String Conditions :

        - If you'd like to add conditions to your find, you could just specify them in there,
        
        Example:
            
            > Book.where("title = 'Introduction to Algorithms'")

                - finds all the books where the title field value is 'Introduction to Algorithms'.


        NOTE : String Conditions are not safe with SQL Injection

        -----------
    3.2 Array Conditions :

        - Now what if that title could vary:

        Example:

            1. > Book.where("title =?", params[:title])

        NOTE : Book.where("title = #{params[:title]}")  <----- this way is NOT reccomended over the Example-1

            
            2. > Book.where("title = ? AND out_of_print = ?", params[:title], false)

                - (?) will get replaced by the array values one by one.

                - In example-2 the 1st(?) will take values from array and 2nd(?) will get value "false" for approach


            3. Placeholder Example:
            
                    > Book.where("created_at >= :start_date AND created_at <= :end_date", 
                                                                    {start_date: params[:start_date], end_date: params[:end_date]})

            4. LIKE Example :

                - Although condition arguments are automatically escaped to prevent SQL injection.
                
                - But, SQL LIKE wildcards (i.e., % and _) are not escaped

                - So we will use "sanitize_sql_like" in these type of cases

                Example:

                    > Book.where("title LIKE ?", Book.sanitize_sql_like(params[:title]) + "%")

        -------------------------------------------
    3.3 Hash Conditions :

        - Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. 

        - Only :
                Equality, Range, and Subset 
                                            checking are possible with Hash conditions.

        Example:

            3.3.1 Equality Condition :

            > Book.where(out_of_print: true)

                Equivalent to - "SELECT * FROM books WHERE (books.out_of_print = 1)"

                ---------------------------------------------------------------------
            
            3.3.2 Range Condition :

                > Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

                -----------------------------------------------------------------------
            
            3.3.3 Subset Condition :

                > Customer.where(orders_count: [1,3,5])

                    Equivalent to - "SELECT * FROM customers WHERE (orders_count IN (1,3,5))"

        --------------------------------------------------------------------------------
    3.4 NOT Condition :

        > Customer.where.not(name: "Rahul")

        --------------------------------------------------
    3.5 OR Condition :

        > Cutomer.where(name: "Rahul").or(Cutomer.where(name: "Suhani"))
        
        --------------------------------------------------------------------------
    3.6 AND Condition :

        > Customer.where(age > 18).and(Cutomer.where(name: "Rahul"))    # .and method

        OR

        > Customer.where(age > 18).where(name: "Rahul"))                # chaining where method
    
    
    -----------------------------------------------------------------------------------------------------

4. ORDER :

    - To retrieve records from the database in a specific order, you can use the order method.

    Example :

        > Book.order(:created_at)
            OR
        > Book.order("created_at")


        > Book.order(created_at: :asc)
            OR
        > Book.order("created_at DESC")


    --------------------------------------------------------------------------------------------------

5. SELECT :

    - By default, "Model.find" selects all the fields from the result set using [ select * ].

    - To select only a subset of fields from the result set, you can specify the subset via the ".select" method.

    Example :

        > Book.select(:isbn, :out_of_print)
                OR
        > Book.select("isbn, out_of_print")

                Equivalent to - " SELECT isbn, out_of_print FROM books "


        > Blog.select(:name)
        >> 
            Blog Load (1.1ms)  SELECT "blogs"."name" FROM "blogs"

            =>                                                                             
            [#<Blog:0x00007f22fc9a20d8 id: nil, name: "Blog_1">,                            
            #<Blog:0x00007f22fc9a1f48 id: nil, name: "Blog_2">]                            


    - DISTINCT SELECT :

        > Customer.select(:last_name).distinct

    --------------------------------------------------------------------------------------------------

6. LIMIT and OFFSET :

    - To apply LIMIT to the SQL fired by the "Model.find", you can specify the LIMIT using limit and offset methods on the relation.


    > Blog.limit(5)     # will select top five records


    > Blog.limit(5).offset(2)   # will first skip 2 records then select 5 records

    --------------------------------------------------------------------------------------------------

7. GROUP :

    - To apply a GROUP BY clause to the SQL fired by the finder, you can use the group method.

    Example:

        > Student.select("age").group("age")

            Equivalent to : " SELECT age FROM students GROUP BY age; "

        
        > Student.group(:city).count    # gets the count of all the distinct cities

            Equivalent to : " SELECT COUNT(city) FROM students GROUP BY city; "

    ---------------------------------------------------------------------------------------------------

8. HAVING :

    - You can add the HAVING clause to the SQL fired by the "Model.find" by adding the "having" method to the find.


    > Student.select("city, COUNT(city) AS city_count")
                .group(:city)
                .having("COUNT(city) > ?", 5)

        Equivalent to : SELECT 
                                city, 
                                COUNT(city) AS city_count 
                        FROM 
                            students 
                        GROUP BY 
                            city 
                        HAVING 
                            COUNT(city) > 5; "


    --> Passing the above Object to a varibale :

    > cities = Student.select("city, COUNT(city) AS city_count")
                        .group(:city)
                        .having("COUNT(city) > ?", 5)

    > cities[0].city_count
    >>      # will return first entry from "city_count" column of above query.

    
    -----------------------------------------------------------------------------------------------------------------------------------

9. Overriding :

    9.1 unscope :

        - You can specify certain conditions to be removed using the "unscope" method.
        
        Example:

            > Book.where('id > 100').limit(20).order('id desc').unscope(:order)

                Equivalent to : SELECT * 
                                FROM books 
                                WHERE id > 100 
                                LIMIT 20

                    - If we haven't used [ .unscope ]

                                : SELECT * 
                                FROM books 
                                WHERE id > 100 
                                ORDER BY id DESC
                                LIMIT 20

        
        - Can remove specific .where conditions too :

            > Student.where(first_name: "Rahul",  last_name: "Gandh").unscope(where: :last_name)

                    Equivalent to - SELECT * FROM students WHERE first_name = "Rahul";

        -------------------------------------------------------------------------------------------------

    9.2 only :

        - Only is opposite of unscope

        - In .only only the methods you mention will get performed.


            > Book.where('id > 10').limit(20).order('id desc').only(:order, :where)

                    Equivalent to : SELECT * FROM books
                                    WHERE id > 10
                                    ORDER BY id DESC

                                    # .limit method is skipped as it wasn't mentioned in .only

        -------------------------------------------------------------------------------------------------------

    9.3 reselect :

        - The reselect method overrides an existing select statement. For example:

            > Student.select(:name, :roll_no).reselect(:age)

                Equivalent to :  SELECT age FROM students;

        --------------------------------------------------------------------------------------------------

    9.4 reorder :

        - If your association have already specified any ordering way. Then you can use .reorder to override it.

        Example:

        Model:
        -----------------------------------------------------
            def Author < ApplicationRecord
                has_many :blogs, -> { order(isbn: :desc) }
            end
        -----------------------------------------------------

        --> When we run

            > Author.find(10).blogs
            >>  # result will be order by isbn: :desc (default)

                Equivalent to : SELECT * FROM blogs
                                WHERE author_id = 10
                                ORDER BY isbn DESC

        --> Overriding Order:

            > Author.find(10).blogs.reorder(:name)
            >>  # result will be ordered by :name

                Equivalent to : SELECT * FROM blogs
                                WHERE author_id = 10
                                ORDER BY name

        -------------------------------------------------------------------------------------------------------

    9.5 reverse_order :

        - The reverse_order method reverses the ordering clause if specified.

            > Blog.order(:id).reverse_order


        - If no ordering clause is specified in the query, the reverse_order orders by the primary key in reverse order.

            > Book.where("author_id > 10").reverse_order


        ---------------------------------------------------------------------------

    9.6 rewhere

        - The rewhere method overrides an existing, named where condition.

        Example :

            > Student.where(age > 10).rewhere(age < 10)

                Equivalent to : SELECT * FROM students WHERE age < 10;

    -------------------------------------------------------------------------------------------------------------------

10. None.

    > Blog.none
    >> []

    -- Returns an empty relation and fires no Queries.

    --------------------------------------------------------------------------------------------

11. Readonly Objects :

    - Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects. 
    
    - Any attempt to alter a readonly record will not succeed, raising an "ActiveRecord::ReadOnlyRecord" exception.

        > blog = Blog.readonly.first

        > blog
        >>
            #<Blog:0x000055b9a7ec47d8                                                                  
            id: 1,                                                                                    
            name: "Blog_1",                                                                           
            author_id: 2,                                                                             
            created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,                               
            updated_at: Mon, 05 Sep 2022 12:17:33.764925000 UTC +00:00>                               
        
        > blog.id = 10
        >> 10

        > blog.save
        >>
            TRANSACTION (0.5ms)  BEGIN
            Author Load (0.6ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
            TRANSACTION (0.4ms)  ROLLBACK                             
            
            ........rb:1123:in `_raise_readonly_record_error': Blog is marked as readonly (ActiveRecord::ReadOnlyRecord)

                # transaction Rolled back because you cannot modify data through this object as this is a readonly object.

        Useful :
                .readonly?
                .readonly!

    ---------------------------------------------------------------------------------------------------------------------------------

12. Locking Records :

    -  Locking is helpful when many people are working on database.

    - Because of locking we can have atomic updates without conflicts.

    - ActiveRecord Support two locking Mechanisms :

        1. Optimistic Locking
        2. Passimistic Locking

    
    12.1 Optimistic Locking :

        - Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. 
        
        - It does this by checking whether another process has made changes to a record since it was opened.

        - An "ActiveRecord::StaleObjectError" exception is thrown if that has occurred and the update is ignored.



        - In order to use optimistic locking, the table needs to have a column called [ "lock_version" ]  of type integer. 
        - Each time the record is updated, Active Record increments the lock_version column

        - If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database, 
                    then the update request will fail with an "ActiveRecord::StaleObjectError".

            
            $ rails g migration AddLockVersionToBlogs lock_version:integer

            > b1 = Blog.first
            > b2 = Blog.first

            > b1.name = "Laptop under 10000"
            > b1. save

            > b1
            >>
                #<Blog:0x000055d4f37051c0
                id: 1,
                name: "Laptops under 10000",
                author_id: 2,
                created_at: Mon, 05 Sep 2022 11:48:17.622306000 UTC +00:00,
                updated_at: Wed, 07 Sep 2022 09:39:37.030568000 UTC +00:00,
                lock_version: 1>

            > b2.name = "New Blog"
            > b2.save
            >>
                TRANSACTION (0.5ms)  BEGIN
                Author Load (0.8ms)  SELECT "authors".* FROM "authors" WHERE "authors"."id" = $1 LIMIT $2  [["id", 2], ["LIMIT", 1]]
                Blog Update (0.9ms)  UPDATE "blogs" SET "name" = $1, "updated_at" = $2, "lock_version" = $3 WHERE "blogs"."id" = $4 AND "blogs"."lock_version" IS NULL  [["name", "New Blog"], ["updated_at", "2022-09-07 09:40:11.766934"], ["lock_version", 1], ["id", 1]]
                TRANSACTION (0.4ms)  ROLLBACK
                
                .......rb:108:in `_update_row': Attempted to update a stale object: Blog. (ActiveRecord::StaleObjectError)

                        *- Transaction / Update isn't completed because the lock version "b2" is older then that in DB.

        
        - This behavior can be turned off by setting ActiveRecord::Base.lock_optimistically = false.

        - To override the name of the lock_version column, ActiveRecord::Base provides a class attribute called locking_column:

                ----------------------------------------
                    class Blog < ApplicationRecord
                        self.locking_column = :lock_blog_column
                    end
                ----------------------------------------

    12.2 Pessimistic Locking :

        - Pessimistic locking uses a locking mechanism provided by the underlying database. 
        
        - Using lock when building a relation obtains an exclusive lock on the selected rows.    

        - This is aDB concept but can be used witjh .with_lock

    -------------------------------------------------------------------------------------------------------------------------------

13. JOINS :

    NOTE : SQL Inner Join is same as JOIN

    
    13.1 String Format :

        Author.joins("JOIN blogs ON (blogs.author_id = author.author_id)")

            Equivalent to : SELECT * FROM authors JOIN blogs ON (blogs.author_id = author.author_id);

        -----------------------------------------------
    13.2 Array / Hash Format :


        13.2.1. Single Association Joining :

        - Active Record lets you use the names of the associations defined on the model as a shortcut for specifying JOIN clauses.
             for those associations when using the joins method.

        Example:
            
            $ rails g migration CreateComments title:string body:text student:references blog:references

            Model :
            ------------------------------------------------------
                class Comment < ApplicationRecord
                    belongs_to :blog 
                end

                class Blog < ApplicationRecord
                    belongs_to :author
                    has_many :comments
                end
            ------------------------------------------------------

                *- Now, When we join tables who are associated to each other.
                        We do not need to mention the column name on which the joinig is based.

                
        ------- > Blog.joins(:comments)
                >>
                    Blog Load (51.7ms)  SELECT "blogs".* FROM "blogs" 
                    INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id"

                
                - Or, in English: "return a Blog object for all blogs with comments". 
                - Note that you will see duplicate blogs if a blog has more than one comment. 
                
                --> If you want unique blogs, you can use Blog.joins(:comments).distinct.
            
            -----------------------------------------
        13.2.2. Multiple Association Joining :

                > Blog.joins(:author, :comments)
                >>

                    Blog Load (1.5ms)  
                        SELECT "blogs".* FROM "blogs" 
                            INNER JOIN "authors" ON "authors"."id" = "blogs"."author_id" 
                            INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 


                    *- Or, in English: "return all blogs with their author that have at least one comment". 
                            Note again that blogs with multiple comments will show up multiple times.

            ----------------------------------------
        13.2.3. Nested Association Joining :

            Model:
            -------------------------------------------------------
                class Comment < ApplicationRecord
                    belongs_to :blog 
                    belongs_to :student
                end

                class Student < ApplicationRecord
                    has_many :comments
                end
            -------------------------------------------------------

                > Blog.join(comments: :student)
                >>
                      Blog Load (1.1ms)  
                        SELECT "blogs".* FROM "blogs" 
                            INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 
                            INNER JOIN "students" ON "students"."id" = "comments"."student_id"

                        *- Or, in English: "return all blogs that have a comment by a student."

            --------------------------------------------------------------------

        13.2.4. Nested Association Joining (Multiple Level) :

        
        ------------------------------------------------------------------

    13.3 Specifying Conditions(.where) on JOINS :

        - Using String :

            > Blog.joins(:comments).where('comments.created_at' => "2022-05-01")

                OR

        - Using Hash :

            > Blog.joins(:comments).where(comments: {created_at: "2022-05-01"})


            >> Blog Load (1.2ms)  
                SELECT "blogs".* FROM "blogs" 
                    INNER JOIN "comments" ON "comments"."blog_id" = "blogs"."id" 
                WHERE "comments"."created_at" = $1  [["created_at", "2022-05-01 00:00:00"]]

        -----------------------------------------------------------------------------------------------

    13.4 LEFT OUTER JOIN :

        - If you want to select a set of records whether or not they have associated records you can use the left_outer_joins method.

            > Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')

            >>  SELECT DISTINCT customers.*, 
                                COUNT(reviews.*) AS reviews_count 
                FROM customers
                LEFT OUTER JOIN reviews 
                        ON reviews.customer_id = customers.id 
                GROUP BY customers.id


    -------------------------------------------------------------------------------------------------------------------------------